package com.每日一题.leetcode.editor.cn;

import com.Utils;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * [每日一题] 2024-08-26 16:13:04
 * 题目名称: 尽量减少恶意软件的传播
 * 题目类型:
 * 思考:
 */


public class Code924_minimizeMalwareSpread {
    public static void main(String[] args) {
        Solution solution = new Code924_minimizeMalwareSpread().new Solution();
//        Object i0 = {{1,1,0},{1,1,0},{0,0,1}};
//        Object i1 = {{1,0,0},{0,1,0},{0,0,1}};
//        Object i2 = {{1,1,1},{1,1,1},{1,1,1}};
        int[] initial = {0, 2};
        int i = solution.minMalwareSpread(Utils.convertStringTo2DArray("[[1,0,0],[0,1,0],[0,0,1]]"), initial);
        System.out.println(i);
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public int minMalwareSpread(int[][] graph, int[] initial) {


            boolean[] visited = new boolean[graph.length];
            int maxValue = -1;

            Arrays.sort(initial);
//            Utils.printTable(initial);
//

            int maxIndex = initial[0];


            for (int i = 0; i < graph.length; i++) {
                if (visited[i]) {
                    continue;
                }
                Set<Integer> visitedSet = new HashSet<>();
                visited[i] = true;
                visitedSet.add(i);
                dfs(graph, i, visited, visitedSet);
//                System.out.println("聚合:" + visitedSet);

                int removeErrorIndex = -1;
                for (int errorNode : initial) {
                    if (visitedSet.contains(errorNode)) {
                        if (removeErrorIndex == -1) {
                            removeErrorIndex = errorNode;
                        } else {
                            removeErrorIndex = -1;
                            break;
                        }
                    }
                }
                if (removeErrorIndex != -1) {
                    if (visitedSet.size() > maxValue) {
                        maxValue = visitedSet.size();
                        maxIndex = removeErrorIndex;

                    }
                    if (visitedSet.size() == maxValue) {
                        maxIndex = Math.min(maxIndex, removeErrorIndex);

                    }
                }

            }
            return maxIndex;
        }


        private void dfs(int[][] graph, int currentNode, boolean[] visited, Set<Integer> visitedSet) {


            for (int i = 0; i < graph[currentNode].length; i++) {
                if (graph[currentNode][i] == 0) {
                    continue;
                }
                if (visited[i]) {
                    continue;
                }
                visited[i] = true;
                visitedSet.add(i);
                dfs(graph, i, visited, visitedSet);
            }

        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}
