先不考虑n的限制，则有3种选取情况：
1. 某一行，所有元素全为0；
2. 某两行，对于每一列，都不会同时出现1； （下面把存在相同列出现1的两行，记为两行冲突）
3. 行数>=3, 行之间两两冲突，但对每一列，1出现的次数<=行数/2。
   (为什么要两两冲突：如果有两行不冲突，则这两行满足情况2，直接返回这两行，不需要再考虑情况3)

* 

```
比如
111000
100110
010101
001011
第0行和第1行因为第0列都有1而冲突；
第0行和第2行因为第1列都有1而冲突；
第0行和第3行因为第2列都有1而冲突；
第1行和第2行因为第3列都有1而冲突；
第1行和第3行因为第4列都有1而冲突；
第2行和第3行因为第5列都有1而冲突。
虽然行之间两两冲突，但他们是满足条件(对每一列，1出现的次数<=行数/2)的解。
```

对第三种情况，要从m<=10^4行里选k(k>=3)行，非常复杂。本题(n<=5)第三种情况必不存在，只需考虑前两种。

* python

```python
class Solution:
    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:
        mp = {}  
        for i,x in enumerate(grid):
            s = 0 
            for b in x:
                s = s << 1 | b 
            mp[s] = i 
        if 0 in mp : return [mp[0] ]
        for x,y in combinations(mp,2):
            if x & y == 0 : #两行不冲突，直接返回
                return sorted([mp[x],mp[y]]) 
        return []
```

证明，n<=5,不存在行之间两两冲突的解。
若了k行之间两两冲突的解存在，则对任意一行，它都要跟其他k-1行冲突。而成为解的前提，对于每一列，1的个数小于等于k/2。
假设选了200行(k=200)，则每列至多有100个1，对任意一行，要通过某一列跟其他行冲突，他自己要先在那一列取1，于是那一列最多剩99个1。
如果他在两列有1，至多跟198行冲突。至少要在3列有1才能跟其余199行冲突。若每行都至少3列有1，则选取的整个矩阵至少有200\*3个1，至多有200\*2个0,必有若干列的1比0多。
一般的，若要假设选取的行数为k,k>=3。每一行要跟k-1行冲突，它每选一个1，至多增加(k/2-1)个与它冲突的行，(k-1)/(k/2-1)必大于2，则至少取3列有1，至多2列取0。
