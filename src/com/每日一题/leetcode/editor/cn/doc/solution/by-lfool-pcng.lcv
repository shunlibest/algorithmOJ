# [å¦‚æœæƒ³è¦æŸ¥çœ‹ä½œè€…æ›´å¤šæ–‡ç« ï¼Œå¯ä»¥ç‚¹å‡»æ­¤å¤„ï¼ï¼ï¼ğŸ”¥ğŸ”¥ğŸ”¥](https://lfool.github.io/LFool-Notes/)

# [ä¸ºäº†æœ¬ç¯‡æ–‡ç« æ›´å¥½çš„è§‚æ„Ÿï¼Œå¯ä»¥ç‚¹å‡»æ­¤å¤„ï¼ï¼ï¼](https://lfool.github.io/LFool-Notes/algorithm/è¯¦è§£å‰ç¼€æ ‘TrieTree.html)

[208. å®ç° Trie (å‰ç¼€æ ‘)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

[648. å•è¯æ›¿æ¢](https://leetcode.cn/problems/replace-words/)

[211. æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

[677. é”®å€¼æ˜ å°„](https://leetcode.cn/problems/map-sum-pairs/)

[676. å®ç°ä¸€ä¸ªé­”æ³•å­—å…¸](https://leetcode.cn/problems/implement-magic-dictionary/)

ã€Œå‰ç¼€æ ‘ã€åˆå«ã€Œå­—å…¸æ ‘ã€æˆ–ã€Œå•è¯æŸ¥æ‰¾æ ‘ã€ï¼Œæ€»ä¹‹å®ƒä»¬æ˜¯ä¸€ä¸ªæ„æ€ï¼

ã€Œå‰ç¼€æ ‘ã€çš„åº”ç”¨åœºæ™¯ï¼šç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²é›†åˆæ„å»ºä¸€æ£µå‰ç¼€æ ‘ï¼Œç„¶åç»™ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ¤æ–­å‰ç¼€æ ‘ä¸­æ˜¯å¦å­˜åœ¨è¯¥å­—ç¬¦ä¸²æˆ–è€…è¯¥å­—ç¬¦ä¸²çš„å‰ç¼€

å¯ä»¥ç»“åˆé¢˜ç›® **[å•è¯æ›¿æ¢](https://leetcode.cn/problems/replace-words/)** ç†è§£ï¼æˆ‘ä»¬éœ€è¦æ ¹æ® `dictionary` æ„å»ºå‰ç¼€æ ‘ï¼Œç„¶ååˆ¤æ–­ `sentence` ä¸­çš„æ¯ä¸ªå•è¯æ˜¯å¦åœ¨å‰ç¼€æ ‘ä¸­

## åˆ†æ

ä¸€èˆ¬è€Œè¨€ï¼Œå­—ç¬¦ä¸²çš„é›†åˆéƒ½æ˜¯ä»…ç”±å°å†™å­—æ¯æ„æˆï¼Œæ‰€ä»¥æœ¬æ–‡ç« éƒ½æ˜¯åŸºäºè¯¥æƒ…å†µå±•å¼€åˆ†æï¼

å­—ç¬¦ä¸²é›†åˆï¼š`[them, zip, team, the, app, that]`ã€‚è¿™ä¸ªæ ·ä¾‹çš„å‰ç¼€æ ‘é•¿ä»€ä¹ˆæ ·å‘¢ï¼Ÿ

![1.svg](https://pic.leetcode-cn.com/1657540498-HHnzlV-1.svg)

ç”±äºéƒ½æ˜¯å°å†™å­—æ¯ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œå‡æœ‰ 26 ä¸ªå­©å­èŠ‚ç‚¹ï¼Œä¸Šå›¾ä¸­æ²¡æœ‰ç”»å‡ºæ¥ï¼Œçœç•¥äº†è€Œå·²...ï¼Œä½†æ˜¯è¦è®°ä½ï¼š**æ¯ä¸ªèŠ‚ç‚¹å‡æœ‰ 26 ä¸ªå­©å­èŠ‚ç‚¹**

**è¿˜æœ‰ä¸€ä¸ªç‚¹è¦æ˜ç¡®ï¼šèŠ‚ç‚¹ä»…ä»…è¡¨ç¤ºä»æ ¹èŠ‚ç‚¹åˆ°æœ¬èŠ‚ç‚¹çš„è·¯å¾„æ„æˆçš„å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆè€Œå·²**

å¯¹äºä¸Šå›¾ä¸­æ©™è‰²çš„èŠ‚ç‚¹ï¼Œå‡ä¸ºæœ‰æ•ˆèŠ‚ç‚¹ï¼Œå³ï¼šä»æ ¹èŠ‚ç‚¹åˆ°æ©™è‰²èŠ‚ç‚¹çš„è·¯å¾„æ„æˆçš„å­—ç¬¦ä¸²å‡åœ¨é›†åˆä¸­

å¦‚æœç°åœ¨è¦æ‰¾å‰ç¼€ `te` æ˜¯å¦å­˜åœ¨ï¼Œåˆ†ä¸¤æ­¥ï¼š

- é¦–å…ˆçœ‹çœ‹è¡¨ç¤º `te` å­—ç¬¦ä¸²çš„è·¯å¾„æ˜¯å¦å­˜åœ¨ï¼Œè¿™ä¸ªä¾‹å­æ˜¯å­˜åœ¨çš„
- å…¶æ¬¡çœ‹çœ‹è¯¥è·¯å¾„çš„ç»ˆç‚¹å¤„çš„èŠ‚ç‚¹æ˜¯å¦æœ‰æ•ˆï¼Œå¾ˆé—æ†¾ï¼Œæ­¤å¤„ä¸ºç™½è‰²ï¼Œæ— æ•ˆ
- æ‰€ä»¥å‰ç¼€ `te` ä¸å­˜åœ¨ï¼ï¼

## æ•°æ®ç»“æ„

ç°åœ¨çœ‹çœ‹å¦‚ä½•è¡¨ç¤ºè¿™æ£µã€Œå‰ç¼€æ ‘ã€ï¼Œå³æ•°æ®ç»“æ„è¯¥å¦‚ä½•å®šä¹‰ã€‚å…¶å®å°±æ˜¯ä¸€æ£µå¤šå‰æ ‘ï¼Œæœ‰ 26 ä¸ªå­©å­èŠ‚ç‚¹çš„å¤šå‰æ ‘è€Œå·²ï¼ï¼

ç°åœ¨æ¥æ€è€ƒèŠ‚ç‚¹çš„å€¼åˆè¯¥å¦‚ä½•è¡¨ç¤ºå‘¢ï¼Ÿ

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼ŒèŠ‚ç‚¹ä»…ä»…è¡¨ç¤ºè·¯å¾„æ„æˆçš„å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆè€Œå·²ï¼Œæ‰€ä»¥èŠ‚ç‚¹å¯ä»¥ç”¨ `boolean` ç±»å‹æ¥è¡¨ç¤º

è¿˜æœ‰ä¸€ç±»æƒ…å†µå°±æ˜¯æ¯ä¸ªå­—ç¬¦ä¸²éƒ½æœ‰ä¸€ä¸ªæƒå€¼ï¼Œæ‰€ä»¥èŠ‚ç‚¹çš„å€¼å¯ä»¥ç”¨ä¸€ä¸ªæ•°å€¼æ¥è¡¨ç¤º

* java

```java
// å‰ç¼€æ ‘çš„æ•°æ®ç»“æ„
class TrieNode {
    boolean val;
    TrieNode[] children = new TrieNode[26];
}
// å‰ç¼€æ ‘çš„æ ¹èŠ‚ç‚¹
private TrieNode root = new TrieNode();
```

## å¸¸ç”¨æ“ä½œ

æ ¹æ®ä¸Šé¢çš„åˆ†æï¼Œå…¶å®ã€Œå‰ç¼€æ ‘ã€å¸¸ç”¨æ“ä½œå°±ä¸‰ç§

- æ ¹æ®æ‰€ç»™å­—ç¬¦ä¸²é›†åˆæ„å»ºå‰ç¼€æ ‘
- åˆ¤æ–­å‰ç¼€æ ‘ä¸­æ˜¯å¦å­˜åœ¨ç›®æ ‡å­—ç¬¦ä¸²
- åœ¨å‰ç¼€æ ‘ä¸­æ‰¾å‡ºç›®æ ‡å­—ç¬¦ä¸²çš„æœ€çŸ­å‰ç¼€

### æ„å»ºå‰ç¼€æ ‘

æœ€åˆï¼Œæˆ‘ä»¬åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ `root`ï¼Œå­©å­èŠ‚ç‚¹ä¹Ÿéƒ½è¿˜æ²¡åˆå§‹åŒ–ï¼

æ‰€ä»¥ç›´æ¥çœ‹ä»£ç ï¼š

* java

```java
// å¾€å‰ç¼€æ ‘ä¸­æ’å…¥ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²
public void insert(String word) {
    TrieNode p = root;
    for (char c : word.toCharArray()) {
        // char -> int
        int i = c - 'a';
        // åˆå§‹åŒ–å­©å­èŠ‚ç‚¹
        if (p.children[i] == null) p.children[i] = new TrieNode();
        // èŠ‚ç‚¹ä¸‹ç§»
        p = p.children[i];
    }
    // æ­¤æ—¶ p æŒ‡å‘ç›®æ ‡å­—ç¬¦ä¸²çš„ç»ˆç‚¹
    p.val = true;
}
```

ä¸ºäº†æ‰©å±•æ€ç»´ï¼Œè¿™é‡Œå†ç»™å‡ºé€’å½’çš„å®ç°æ–¹æ³•ï¼š(å’Œæ ‘çš„éå†å¾ˆåƒ)

* java

```java
public TrieNode insert(TrieNode node, String word, int index) {
    // åˆå§‹åŒ–
    if (node == null) node = new TrieNode();
    // åˆ°äº†ç»ˆç‚¹
    if (index == word.length()) {
        node.val = true;
        return node;
    }
    int i = word.charAt(index) - 'a';
    node.children[i] = insert(node.children[i], word, index + 1);
    return node;
}
// è°ƒç”¨æ–¹æ³•
root = insert(root, word, 0);
```

### å¯»æ‰¾ç›®æ ‡å­—ç¬¦ä¸²

å½“ã€Œå‰ç¼€æ ‘ã€æ„å»ºå¥½äº†åï¼Œå¯»æ‰¾ç›®æ ‡å­—ç¬¦ä¸²ä¹Ÿå°±å¤§åŒå°å¼‚äº†

å¤ä¹ ä¸€ä¸‹å¯»æ‰¾çš„ä¸¤ä¸ªæ­¥éª¤ï¼š

- é¦–å…ˆçœ‹çœ‹è¡¨ç¤ºå­—ç¬¦ä¸²çš„è·¯å¾„æ˜¯å¦å­˜åœ¨
- å…¶æ¬¡çœ‹çœ‹è¯¥è·¯å¾„çš„ç»ˆç‚¹å¤„çš„èŠ‚ç‚¹æ˜¯å¦æœ‰æ•ˆ

* java

```java
public boolean query(String word) {
    TrieNode p = root;
    for (char c : word.toCharArray()) {
        int i = c - 'a';
        // è·¯å¾„ä¸å­˜åœ¨çš„æƒ…å†µï¼Œç›´æ¥è¿”å› false
        if (p.children[i] == null) return false;
        p = p.children[i];
    }
    // è·¯å¾„å­˜åœ¨ï¼Œç›´æ¥è¿”å›è¯¥è·¯å¾„çš„ç»ˆç‚¹å¤„çš„èŠ‚ç‚¹çš„æœ‰æ•ˆæ€§
    return p.val;
}
```

åŒæ ·çš„ï¼Œä¸ºäº†æ‰©å±•æ€ç»´ï¼Œè¿™é‡Œå†ç»™å‡ºé€’å½’çš„å®ç°æ–¹æ³•ï¼š(å’Œæ ‘çš„éå†å¾ˆåƒ)

* java

```java
public boolean query(TrieNode node, String word, int index) {
    // è·¯å¾„ä¸å­˜åœ¨çš„æƒ…å†µ
    if (node == null) return false;
    // è·¯å¾„å­˜åœ¨ï¼Œç›´æ¥è¿”å›è¯¥è·¯å¾„çš„ç»ˆç‚¹å¤„çš„èŠ‚ç‚¹çš„æœ‰æ•ˆæ€§
    if (index == word.length()) return node.val;
    
    int i = word.charAt(index) - 'a';
    return query(node.children[i], word, index + 1);
}
// è°ƒç”¨æ–¹æ³•
query(root, word, 0);
```

### å¯»æ‰¾æœ€çŸ­å‰ç¼€

å’Œã€Œå¯»æ‰¾ç›®æ ‡å­—ç¬¦ä¸²ã€å·®ä¸å¤šï¼Œä½†åˆæœ‰äº›è®¸ä¸åŒ

- ã€Œå¯»æ‰¾ç›®æ ‡å­—ç¬¦ä¸²ã€å¿…é¡»éå†åˆ°ç›®æ ‡å­—ç¬¦ä¸²çš„æœ«å°¾ï¼Œç„¶åå†åˆ¤æ–­è·¯å¾„æ˜¯å¦æœ‰æ•ˆ

- ã€Œå¯»æ‰¾æœ€çŸ­å‰ç¼€ã€åªè¦åœ¨éå†çš„è¿‡ç¨‹æœ‰ä¸­ï¼Œé¦–æ¬¡å‡ºç°äº†æœ‰æ•ˆè·¯å¾„ï¼Œå³ä¸ºæ‰¾åˆ°ï¼ï¼

* java

```java
public String shortestPrefixOf(String word) {
    TrieNode p = root;
    StringBuffer sb = new StringBuffer();
    for (char c : word.toCharArray()) {
        int i = c - 'a';
        // é¦–æ¬¡é‡åˆ°æœ‰æ•ˆè·¯å¾„ï¼Œç›´æ¥è¿”å›
        if (p.val) return sb.toString();
        sb.append(c);
        // è·¯å¾„ä¸å­˜åœ¨çš„æƒ…å†µï¼Œç›´æ¥è¿”å› ""
        if (p.children[i] == null) return "";
        p = p.children[i];
    }
    // æ²¡æ‰¾åˆ°
    return "";
}
```

## é«˜çº§æ“ä½œ

### å«æœ‰é€šé…ç¬¦çš„å¯»æ‰¾

é¡¾åæ€ä¹‰ï¼Œ`.`å¯ä»¥è¡¨ç¤ºä»»ä½•å­—ç¬¦ã€‚æ¯”å¦‚ï¼š`a.c` æ˜¯å¯ä»¥å’Œ `[abc, aec]` åŒ¹é…çš„

* java

```java
public boolean keysWithPattern(TrieNode node, String pattern, int index) {
    if (node == null) return false;
    if (index == key.length()) return node.val;
    int i = key.charAt(index) - 'a';
    // å¦‚æœæ˜¯é€šé…ç¬¦ï¼Œç›´æ¥å’Œ 26 ä¸ªå­—æ¯åŒ¹é… (ç®€å•ç²—æš´ï¼ï¼)
    if (key.charAt(index) == '.') {
        for (int j = 0; j < 26; j++) {
            if (search(node.children[j], key, index + 1)) return true;
        }
        return false;
    } else {
        return search(node.children[i], key, index + 1);
    }
}
```

## é¢˜ç›®å®æˆ˜

### å®ç° Trie (å‰ç¼€æ ‘)

**é¢˜ç›®è¯¦æƒ…å¯è§ [å®ç° Trie (å‰ç¼€æ ‘)](https://leetcode.cn/problems/implement-trie-prefix-tree/)**

* java

```java
class Trie {
    class TrieNode {
        boolean val;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode p = root;
        for (char c : word.toCharArray()) {
            int i = c - 'a';
            if (p.children[i] == null) p.children[i] = new TrieNode();
            p = p.children[i];
        }
        p.val = true;
    }
    
    public boolean search(String word) {
        TrieNode p = root;
        for (char c : word.toCharArray()) {
            int i = c - 'a';
            if (p.children[i] == null) return false;
            p = p.children[i];
        }
        return p.val;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (char c : prefix.toCharArray()) {
            int i = c - 'a';
            if (p.children[i] == null) return false;
            p = p.children[i];
        }
        return true;
    }
}
```

### å•è¯æ›¿æ¢

**é¢˜ç›®è¯¦æƒ…å¯è§ [å•è¯æ›¿æ¢](https://leetcode.cn/problems/replace-words/)**

* java

```java
class Solution {
    class TrieNode {
        boolean val;
        TrieNode[] children = new TrieNode[26];
    }
    
    private TrieNode root = new TrieNode();
    
    public String replaceWords(List<String> dictionary, String sentence) {
        for (String d : dictionary) root = insert(root, d, 0);
        StringBuffer ans = new StringBuffer();
        for (String s : sentence.split(" ")) {
            String q = query(s);
            if ("".equals(q)) ans.append(s).append(" ");
            else ans.append(q).append(" ");
        }
        ans.deleteCharAt(ans.length() - 1);
        return ans.toString();
    }
    
    private TrieNode insert(TrieNode node, String key, int index) {
        if (node == null) node = new TrieNode();
        if (index == key.length()) {
            node.val = true;
            return node;
        }
        int i = key.charAt(index) - 'a';
        node.children[i] = insert(node.children[i], key, index + 1);
        return node;
    }
    
    private String query(String key) {
        TrieNode p = root;
        StringBuffer ans = new StringBuffer();
        for (char c : key.toCharArray()) {
            int i = c - 'a';
            if (p.val) return ans.toString();
            ans.append(c);
            if (p.children[i] == null) return "";
            p = p.children[i];
        }
        return "";
    }
}
```

### æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡

**é¢˜ç›®è¯¦æƒ…å¯è§ [æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)**

* java

```java
class WordDictionary {

    class TrieNode {
        boolean val;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }
    
    public void addWord(String word) {
        TrieNode p = root;
        for (char c : word.toCharArray()) {
            int i = c - 'a';
            if (p.children[i] == null) p.children[i] = new TrieNode();
            p = p.children[i];
        }
        p.val = true;
    }
    
    public boolean search(String word) {
        return search(root, word, 0);
    }

    private boolean search(TrieNode node, String key, int index) {
        if (node == null) return false;
        if (index == key.length()) return node.val;
        int i = key.charAt(index) - 'a';
        if (key.charAt(index) == '.') {
            for (int j = 0; j < 26; j++) {
                if (search(node.children[j], key, index + 1)) return true;
            }
            return false;
        } else {
            return search(node.children[i], key, index + 1);
        }
    }
}
```

### é”®å€¼æ˜ å°„

**é¢˜ç›®è¯¦æƒ…å¯è§ [é”®å€¼æ˜ å°„](https://leetcode.cn/problems/map-sum-pairs/)**

è¿™ä¸ªé¢˜ç›®äº›è®¸ä¸åŒï¼Œæ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºçš„ä¸å†æ˜¯æ˜¯å¦æœ‰æ•ˆï¼Œè€Œæ˜¯ä¸€ä¸ªå€¼

* java

```java
class MapSum {

    class TrieNode {
        int val;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public MapSum() {
        root = new TrieNode();
    }
    
    public void insert(String key, int val) {
        TrieNode p = root;
        for (char c : key.toCharArray()) {
            int i = c - 'a';
            if (p.children[i] == null) p.children[i] = new TrieNode();
            p = p.children[i];
        }
        p.val = val;
    }
    
    public int sum(String prefix) {
        TrieNode p = root;
        // æ‰¾åˆ°å‰ç¼€ prefix çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
        for (char c : prefix.toCharArray()) {
            int i = c - 'a';
            if (p.children[i] == null) return 0;
            p = p.children[i];
        }
        return getAllSum(p);
    }
    // è¾…åŠ©å‡½æ•°ï¼Œæ±‚ä»¥ node ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘çš„èŠ‚ç‚¹å’Œ 
    private int getAllSum(TrieNode node) {
        if (node == null) return 0;
        int sum = 0;
        for (int i = 0; i < 26; i++) {
            sum += getAllSum(node.children[i]);
        }
        return sum + node.val;
    }
}
```

### å®ç°ä¸€ä¸ªé­”æ³•å­—å…¸

**é¢˜ç›®è¯¦æƒ…å¯è§ [å®ç°ä¸€ä¸ªé­”æ³•å­—å…¸](https://leetcode.cn/problems/implement-magic-dictionary/)**

ç”±äºæœ¬é¢˜ç›®å¿…é¡»æ›¿æ¢ä¸€æ¬¡ï¼Œæ‰€ä»¥é‡‡å–äº†ä¸€ä¸ªå‚»åŠæ³•ï¼šéå†æ¯ä¸€ç§æ›¿æ¢çš„æƒ…å†µ

* java

```java
class MagicDictionary {

    class TrieNode {
        boolean val;
        TrieNode[] children = new TrieNode[26];
    }

    private TrieNode root;

    public MagicDictionary() {
        root = new TrieNode();
    }
    
    public void buildDict(String[] dictionary) {
        for (String word : dictionary) {
            TrieNode p = root;
            for (char c : word.toCharArray()) {
                int i = c - 'a';
                if (p.children[i] == null) p.children[i] = new TrieNode();
                p = p.children[i];
            }
            p.val = true;
        }
    }
    
    public boolean search(String searchWord) {
        // éå†æ¯ä¸€ç§æ›¿æ¢çš„æƒ…å†µ
        for (int i = 0; i < searchWord.length(); i++) {
            if (search(root, searchWord, 0, i)) return true;
        }
        return false;
    }

    private boolean search(TrieNode node, String searchWord, int index, int changeId) {
        if (node == null) return false;
        if (index == searchWord.length()) return node.val;
        int i = searchWord.charAt(index) - 'a';
        if (index == changeId) {
            for (int j = 0; j < 26; j++) {
                if (j == i) continue;
                if (search(node.children[j], searchWord, index + 1, changeId)) return true;
            }
            return false;
        }
        return search(node.children[i], searchWord, index + 1, changeId);
    }
}
```

