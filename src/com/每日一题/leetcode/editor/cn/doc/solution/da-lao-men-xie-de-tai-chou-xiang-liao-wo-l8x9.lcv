前边dp计算的步骤，就不讲解了，每个题解都有，这个好理解，dp[i]=dp[i-1]+dp[i-2]。我是找规律试出来的。
说一下两个问题：
1. 每一位1取0计算之后的数，为什么到连续1的时候，就退出循环，直接return呢？

我们拿1011010举例子：
- 第一位1变0，求0-0111111范围内，不连续1的个数，dp[7-1]的个数
- 第三位1变0，求1000000-1001111范围内，不连续1的个数，dp[7-3]的个数
- 第四位1变0，求1010000-1010111范围内，不连续1的个数，dp[7-4]的个数
- 第六位1变0，求1011000-1011001范围内，不连续1的个数。此时前面已有连续1，忽略不计。
- 后面所有的数，都是在1011xxx基础上求数，已经不符合条件了，退出循环。

2. 为什么不在循环里的return，结果要+1呢？

我们拿101000举例子：
- 第一位1变0，求0-011111范围内，不连续1的个数；
- 第三位1变0，求100000-100111范围内，不连续1的个数；

此时for循环结束，我们要在for循环外return，但是我们还忽略了一个数，那就是101000本身，他也符合条件。所以循环外的return，结果要+1。

注：如果执行到循环外进行return，那么n肯定是一个符合条件的数值。如果n有连续1，则在for循环里面就已经return了。

* 

```
var findIntegers = function(n) {
    // 按位计算
    // dp[i]表示一个i位二进制数2^i-1，dp[i] = dp[i-1] + dp[i-2]

    const dp = [1,2];

    for(let i=2;i<32;i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    // 逐位求每一个位数为1的数，把1变成0的个数
    // 比如1011010
    // 第一位1变0，求0-0111111，dp[7-1]的个数
    // 第三位1变0，求1000000-1001111，dp[7-3]的个数
    // 第四位1变0，求1010000-1010111，dp[7-4]的个数
    // 第六位1变0，求1011000-1011001，前面有连续1，忽略不计
    // 所以在有连续1的时候，即可退出循环

    // 二进制n
    let res = 0;
    const nB = n.toString(2);
    const len = nB.length;
    for(let i=0;i<len;i++) {
        if(nB[i] === '1') {
            res += dp[len-i-1];
            if(nB[i-1] === '1') {
                return res;
            }
        }
    }
    // 为什么要+1
    // 举例：101进行变换
    // 第一位变0，000-011，dp[3-1]=3
    // 第三位变0，100-100，dp[3-3]=1
    // 但是最后一位为1的时候，忽略了一个数，就是101本身
    // 我们在计算一个n时，会把n各位为1的数变换后，求结果。
    // 如果这个n本身存在连续1，我们在循环里就已经返回了。
    // 如果这个n不存在连续1，那我们退出循环，计算的时候，要给结果+1，加上n本身。
    return res+1;
};
```

