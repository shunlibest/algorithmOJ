# å›¾çš„åŸºæœ¬æ¦‚å¿µåŠæœ¯è¯­

![Screenshot 2024-06-16 at 9.00.42 AM.png](https://pic.leetcode.cn/1718499665-pRMLwy-Screenshot%202024-06-16%20at%209.00.42%20AM.png)

è¯»è€…å¯èƒ½ä¸ç†Ÿæ‚‰å›¾è®ºåŸºç¡€çŸ¥è¯†çš„ä¸€äº›ç¬¦å·ï¼Œç‰¹æ­¤è§£é‡Šä¸€éƒ¨åˆ†ã€‚çªç„¶æ¥æ”¶è¿™ä¹ˆå¤šçŸ¥è¯†ç¡®å®æœ‰äº›æŒ‘æˆ˜ï¼Œè·Ÿç€å­¦æœ¯ä¸€ç‚¹çš„å›¾è®ºæ•™ç¨‹é€æ­¥å­¦åˆ°è¿™é‡Œä¼šå¥½å¾ˆå¤šï¼Œå…·ä½“å¯å‚è€ƒ[ã€Šå›¾è®ºå…¥é—¨ã€‹](https://leetcode.cn/leetbook/detail/introduction-to-graph/)ã€‚

- $G$ï¼šå›¾
- $V$: ç‚¹é›†, åœ¨ä¸Šå›¾ä¸­ï¼Œ$V = \{a,b,c,d,e,f\}$
- $E$ï¼šè¾¹é›†
- $w$: æƒé‡å‡½æ•°ï¼Œä¸Šå›¾ä¸­è¾¹ä¸Šçš„æ•°å­—ï¼Œæ¯”å¦‚ $w(c,a) = 1$ã€‚è¯»è€…å¦‚æœä¸ç†Ÿæ‚‰å›¾ç†è§£ä¸ºè¾¹çš„é•¿åº¦å³å¯ã€‚
- $\forall$: ä»»æ„
- $(u, v)$:  ä»ç‚¹ $u$ åˆ°ç‚¹ $v$ çš„è¾¹ï¼Œä¸€èˆ¬è¡¨ç¤ºèƒ½ä» $u$ èµ°å‘ $v$ã€‚
- $\in$: å±äº

æ‰€ä»¥ $\forall (u, v) \in E, w(u,v) \geq 0$ è¡¨ç¤ºè¾¹é›†ä¸­ä»»æ„è¾¹çš„æƒé‡ $\geq 0$ã€‚

å…¶ä»–çš„ç›¸å…³ç¬¦å·è¿˜æœ‰ï¼š

- $|V|$ æˆ–è€… $|G.V|$è¡¨ç¤ºé›†åˆ $V$ çš„ size
- $\delta(u,v)$ è¡¨ç¤ºå›¾ä¸­ $u, v$ ä¸¤ç‚¹çš„è·ç¦»ï¼ˆæœ€çŸ­è·¯å¾„çš„æƒé‡å’Œï¼‰ã€‚
- $V_\delta \cup \{e\}$ è¡¨ç¤ºå‘ç‚¹é›† $V_\delta$ ä¸­åŠ å…¥ç‚¹ $e$ã€‚
- $G.Adj$ è¡¨ç¤ºé‚»æ¥è¡¨, ä¸Šå›¾ä¸­ $G.Adj[c] = \{a,d\}$ã€‚å­˜å‚¨ä»å„ç‚¹å‡ºå‘çš„å¯ç›´è¾¾ç‚¹ä»¥åŠæƒé‡ï¼Œä½†åœ¨å­¦æœ¯ä¸­æƒé‡ç”¨æƒé‡å‡½æ•° ğ‘¤ æ¥è¡¨è¾¾ã€‚

# æœ€çŸ­è·¯å¾„

**æœ€çŸ­è·¯å¾„ (shortest paths)** çš„ç›¸å…³å®é™…åœºæ™¯æ¯”è¾ƒå¹¿æ³›ï¼Œæ¯”å¦‚åœ°å›¾ã€ç½‘ç»œç­‰ã€‚

**å•æºæœ€çŸ­è·¯å¾„ (SSSP / single-source shortest paths)** æ˜¯æ±‚è§£ç»™å®šæŸä¸€æºç‚¹åˆ°å…¶æ‰€æœ‰å¯è¾¾ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œå³ä½¿å¾—è¿™äº›æ— æƒè·¯å¾„çš„è¾¹æ•°æˆ–è€…å¸¦æƒè·¯å¾„çš„æƒé‡å’Œæœ€å°ã€‚

Dijkstra ç®—æ³•è§£å†³çš„æ˜¯éè´Ÿæƒå›¾çš„ SSSPï¼Œæœªä½¿ç”¨å †æŸ¥æ‰¾ä¼˜åŒ–æ—¶ï¼Œä¹Ÿè¢«ç§°ä¸º Dijkstra æš´åŠ›ç®—æ³•ã€‚

Dijkstra å‘éŸ³ /ËˆdaÉªkstrÉ™/ï¼Œè¯‘ä½œâ€œè¿ªæ°æ–¯ç‰¹æ‹‰â€œã€‚

# æ¾å¼› (Relax)

"æ¾å¼›"è¿™ä¸ªæœ¯è¯­å‡ºç°å¾—è¾ƒå¤šï¼Œå«ä¹‰åŒæ•°å­¦æ„ä¹‰ä¸Šçš„æ¾å¼›ç›¸åŒï¼Œå‡å°‘å£°æ˜æˆç«‹çš„çº¦æŸæ¡ä»¶ã€‚å›¾çš„ä¸¤ç‚¹ä¹‹é—´å­˜åœ¨å¤šæ¡è·¯å¾„ï¼Œæ‰¾åˆ°æœ€çŸ­çš„ä¸€æ¡éœ€è¦æ¯”è¾ƒï¼Œæ¯æ¯”è¾ƒä¸€æ¬¡å°±å‡å°‘ä¸€æ¬¡çº¦æŸã€‚

> ä½†æˆ‘è®¤ä¸ºæ­¤å¤„ä»æ•°å­¦ä¸­æ²¿ç”¨è¿™ä¸ªå‘½åå¹¶ä¸å¥½ã€‚

![introduction1.png](https://pic.leetcode.cn/1715996701-UmGZfM-introduction1.png)
ä¸Šå›¾è¡¨ç¤ºåœ¨ SSSP ä¸­ï¼Œå¿½ç•¥åŸå›¾ä¸­çš„å…¶ä»–ç‚¹å’Œè¾¹ï¼Œæ¢ç´¢è¿‡ç¨‹ä¸­æŸä¸€æ—¶åˆ»ç‚¹ A å¯¹å…¶é‚»æ¥ç‚¹çš„æ¾å¼›ã€‚

çº¢æ¡†ä¸­çš„ä¸‹æ ‡ï¼š

- ç¬¬ä¸€ä¸ªï¼šåœ¨å½“å‰æ¢ç´¢èŒƒå›´å†…ï¼Œæºç‚¹åˆ°è¯¥ç‚¹çš„çš„è·ç¦»ã€‚
- ç¬¬äºŒä¸ªï¼šç›¸åº”è·¯å¾„ä¸Šçš„çˆ¶èŠ‚ç‚¹ã€‚å’Œå„é¡¶ç‚¹ä¸€æ ·ï¼Œéƒ½æ˜¯å®é™…ä»¥æ•°å­—å­˜å‚¨ã€‚A å³ 0, B å³ 1ï¼Œä»¥æ­¤ç±»æ¨ï¼Œ-1 è¡¨ç¤ºæ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚

è§‚å¯Ÿ A B ä¸¤ç‚¹çŠ¶æ€ï¼Œ3 + 1 < 5ï¼Œè¯´æ˜ A ç‚¹æ‰€å¤„è·¯å¾„å‘ B å»¶ä¼¸åæ¯”æ­¤å‰æºç‚¹åˆ° B çš„è·¯å¾„æ›´çŸ­ï¼Œæ¾å¼›æœ‰æ•ˆã€‚

åŒç†å¯å¾—å¯¹ C æ¾å¼›æœ‰æ•ˆï¼Œå¯¹ D æ¾å¼›æ— æ•ˆã€‚

å¦‚æœä¹‹åæŸåˆ» A ç‚¹å†æ¬¡è¢«æœ‰æ•ˆæ¾å¼›äº†ï¼Œé‚£ä¹ˆåº”è¯¥ç»§ç»­æ¾å¼› B C D ç‚¹ã€‚

# åŸç†

![dijkstra1.png](https://pic.leetcode.cn/1715996816-xOnJSZ-dijkstra1.png)

å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œç»™å®šå›¾ $G = (V, E, w)ï¼Œ\forall (u,v) \in E, \ w(u,v)\geq 0$ã€‚$a$ ä¸ºæºç‚¹ï¼Œæ±‚å…¶åˆ°å„å¯è¾¾ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

è®¾çº¢æ¡†åŒºåŸŸä¸­çš„ç‚¹é›†ä¸º $V_\delta$ï¼Œè¡¨ç¤º $V$ ä¸­å‰ $|V_\delta|$ ä¸ªä» $a$ å‡ºå‘æœ€è¿‘çš„ç‚¹ã€‚

è®°æŸæ—¶åˆ» $V_{\delta} = \{a, c, d, f\}$ã€‚è¿™ä¸ Prim ç®—æ³•å¾ˆç›¸ä¼¼ã€‚

ä» $V_\delta$ å¤–çš„å¯ç›´è¾¾ç‚¹ $b, e$ ä¸­é€‰æ‹©ç¦» $a$ æœ€è¿‘çš„ $e$ ç‚¹ï¼Œè®°å½•ç›¸åº”è·¯å¾„ $\langle a, d, e\rangle$ å’Œå…¶é•¿åº¦ã€‚

ä» $V_\delta$ å¤–çš„ä¸å¯ç›´è¾¾ç‚¹ $h, g$ ä¸­ä»»é€‰ä¸€ç‚¹è®°ä¸º $v^\leadsto$ï¼Œè·¯å¾„ $a \leadsto v^\leadsto$ ä¸Šä¸€å®šè‡³å°‘ç»è¿‡ $b$ æˆ– $e$ã€‚è®°è¯¥ç‚¹ä¸º $v^\rightarrow \in \{b, e\}$ï¼Œè·¯å¾„ä¸º $a \leadsto v^\rightarrow \leadsto v^\leadsto$ã€‚

æ—¢ç„¶ $\forall (u,v) \in E,\ w(u, v) \geq 0$ï¼Œåˆ™ $\delta(a, v^\rightarrow) \leq \delta(a, v^\leadsto)$

æ ¹æ® $e$ ç‚¹çš„é€‰æ‹©æ¡ä»¶å¯çŸ¥ $\delta(a, e) \leq \delta(a, v^\rightarrow)$ï¼Œç»“åˆä¸Šå¼å¯å¾— $\delta(a, e) \leq \delta(a, v^\leadsto)$

æ‰€ä»¥ $e$ ä¸º $\{b,e,h,g\}$ å³ $V- V_\delta$ ä¸­ç¦» $a$ æœ€è¿‘çš„ç‚¹ï¼Œæ­¤å‰è®°å½•çš„ $\langle a,d,e \rangle$ ä¸ºæœ€çŸ­è·¯å¾„ã€‚

![dijkstra2.png](https://pic.leetcode.cn/1715996841-MRaszQ-dijkstra2.png)

å¦‚ä¸Šæ‰€ç¤ºï¼Œä»¤ $V_\delta = V_\delta \cup \{e\}$ã€‚å†æ‰§è¡Œä¸Šä¸€æ­¥ï¼Œé€æ¸æ‰©å¼ å³å¯æ‰¾åˆ° $a$ åˆ°æ‰€æœ‰å¯è¾¾ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

> åˆå§‹ $V_\delta = \{a\}$

Dijkstra ç®—æ³•å’Œ Prim ç®—æ³•ç›¸æ¯”ï¼Œå–å¾—å‘¨å›´æœ€è¿‘ç‚¹çš„æ€è·¯æœ‰æ‰€å˜åŒ–ï¼Œè¯¦è§ä¸‹é¢çš„ç®—æ³•å®ç°ã€‚

# PPT æ±‚è§£å±•ç¤º

æ¾å¼›éƒ¨åˆ†è¢«æˆ‘æŠ½ç¦»ä¸ºä¸‹æ–¹è¿™ä¸ªå‡½æ•°ï¼Œè¡¨ç¤ºæ¾å¼›ç‚¹ $u$ çš„æ‰€æœ‰é‚»æ¥ç‚¹ã€‚
- $D$ ä¸ºæ•°ç»„ Distancesï¼Œè¡¨ç¤ºåœ¨å½“å‰æ¢ç´¢èŒƒå›´å†…ï¼Œæºç‚¹åˆ°å„ç‚¹çš„è·ç¦»ã€‚
- $P$ ä¸ºæ•°ç»„ Parentsï¼Œè¡¨ç¤ºç›¸åº”è·¯å¾„ä¸Šçš„çˆ¶èŠ‚ç‚¹ã€‚
- $D$ å’Œ $P$ çš„æ•°ç»„ä¸‹æ ‡è¡¨ç¤ºé¡¶ç‚¹ã€‚

![dijkstra3.png](https://pic.leetcode.cn/1715996874-KnFOAy-dijkstra3.png)

> è¯»è€…åœ¨åˆæ¬¡æ¥è§¦ä¼ªä»£ç æ—¶ä¼šä¸ä¹ æƒ¯ã€‚ä½†æ®ç¬”è€…çš„è°ƒæŸ¥åé¦ˆï¼Œä¹ æƒ¯åä½“éªŒè¿˜æ˜¯ä¸é”™çš„ã€‚
> åœ¨ä¸‹æ–¹çš„ä»£ç ä¸­ï¼Œ$[-1] \times |G.V|$ è¡¨ç¤ºé•¿åº¦ä¸º $|G.V|$ï¼Œå…ƒç´ éƒ½ä¸º $-1$ çš„æ•°ç»„ã€‚å…·ä½“çš„æœ¯è¯­å’Œç¬¦å·å‡åœ¨[ã€Šå›¾è®ºå…¥é—¨ã€‹](https://leetcode.cn/leetbook/detail/introduction-to-graph/)çš„é™„å½•ä¸­æœ‰ä»‹ç»ã€‚

<![sssp.001.jpeg](https://pic.leetcode.cn/1715996138-qTSvkP-sssp.001.jpeg),![sssp.002.jpeg](https://pic.leetcode.cn/1715996144-FrtdvL-sssp.002.jpeg),![sssp.003.jpeg](https://pic.leetcode.cn/1715996148-lPCjQA-sssp.003.jpeg),![sssp.004.jpeg](https://pic.leetcode.cn/1715996151-zAPyse-sssp.004.jpeg)>

è®°æºç‚¹**åª**é€šè¿‡å·²çŸ¥çš„ $V_\delta$ åˆ°å‘¨å›´å¯ç›´è¾¾ç‚¹çš„æœ€çŸ­è·ç¦»å’Œè·¯å¾„ä¸º $f(V_\delta)$ã€‚

å¯å¾—å¦‚æœæŸä¸€æ¬¡æ¾å¼›å‰ï¼Œæˆ‘ä»¬å·²ç»ç¡®å®šäº† $V_\delta$ å’Œ $f(V_\delta)$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯æ ¹æ®ä»¥ä¸Šè¯æ˜å– $V_\delta$ å¤–ç¦»æºç‚¹æœ€è¿‘çš„ä¸€ç‚¹çº³å…¥ $V_\delta$ï¼Œè€Œä¸”æ¾å¼›è¯¥ç‚¹çš„é‚»æ¥ç‚¹åå°±å¯ä»¥æ›´æ–° $f(V_\delta)$ã€‚

# å®Œæ•´ä»£ç 

![code1.png](https://pic.leetcode.cn/1715996913-XLuqaF-code1.png)

æ€è€ƒä¸ºä»€ä¹ˆæ¾å¼›å‰ä¸ç”¨åˆ¤æ–­ç‚¹ $nearestV$ çš„é‚»æ¥ç‚¹æ˜¯å¦ settled?

ç­”ï¼šå› ä¸ºå¤„äº settled çš„ç‚¹å·²ç»æ‰¾åˆ°æœ€çŸ­è·ç¦»ï¼Œæ¾å¼›ä¼šä¸€ç›´æ— æ•ˆã€‚

> é™¤ Settled å¤–è¿˜æœ‰ä¸€äº›å¸¸è§çš„å‘½åï¼Œå¦‚ Visitedã€Doneã€Usedã€‚ä»è¯­ä¹‰ä¸Šæ¥çœ‹ï¼ŒSettled å’Œ Done æ›´åŠ åˆé€‚ä¸€äº›ã€‚

> åœ¨å¾ˆå¤šåªè€ƒè™‘è·ç¦»çš„åº”è¯•é¢˜ä¸­ï¼Œ$D[v]$ çš„æ›´æ–°å¯ä»¥ç®€å†™ä¸º $D[v] = min(D[v],\  D[nearestV] + w(nearestV, v))$ã€‚

# å¤æ‚åº¦

æ—¶é—´ï¼š$O(V^2)$
ç©ºé—´ï¼š$\Theta(V)$

ä¸ Prim ç®—æ³•çš„å¤æ‚åº¦åˆ†æå¤§ä½“ç›¸åŒï¼Œä½†æœ¬ç« è€ƒè™‘ä¸å¯è¾¾å¯¼è‡´æå‰æˆªæ­¢çš„æƒ…å†µï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸æ˜¯ $\Theta(V^2)$ã€‚è¿˜å¯ä»¥ç”¨å †æŸ¥æ‰¾ä¼˜åŒ–ï¼Œä½†å®ç°ç¨å¤æ‚ï¼Œè¿™åœ¨[ã€Šå›¾è®ºè¿›é˜¶ã€‹](https://leetcode.cn/leetbook/read/advanced-graph-theory/ivu4fs/)ä¸­æœ‰è®²åˆ°ã€‚

# æœ¬é¢˜è§£æ³•

Dijkstra ç®—æ³•ä¸­çš„æƒé‡ç´¯è®¡æ–¹å¼æ˜¯ç›¸åŠ ï¼Œç§‰æ‰¿éé€’å‡åŸåˆ™ï¼Œæœ€çŸ­è·¯å¾„ä¸Šçš„æƒé‡å’Œæœ€å°ã€‚

æœ¬é¢˜çš„æƒé‡ç´¯è®¡æ–¹å¼æ˜¯ç›¸ä¹˜ï¼Œä½†æƒé‡(æ¦‚ç‡ï¼‰$\in [0, 1]$ï¼Œç§‰æ‰¿éé€’å¢åŸåˆ™ï¼Œæ±‚è§£æ¦‚ç‡æœ€å¤§çš„è·¯å¾„ã€‚

æ‰€ä»¥å¯ä»¥é•œåƒè½¬æ¢æ¾å¼›è¿‡ç¨‹ï¼Œä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚

> æ³¨æ„ä»£ç ä¸­çš„ su\***rob æ˜¯è¯¯è§¦åˆ°å±é™©è¯è¯­è¢«å’Œè°äº†ï¼

* []

```C++
class Solution {
public:
    struct Edge {
        int v;
        double prob;
        Edge(int v, double prob) : v(v), prob(prob) {}
    };

    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& suï¼Šï¼Šï¼Šrob, int start_node, int end_node) {
        // æ„å»ºé‚»æ¥è¡¨
        vector<vector<Edge>> adj(n);
        for (int i = 0; i < edges.size(); ++i) {
            int u = edges[i][0], v = edges[i][1];
            adj[u].emplace_back(v, suï¼Šï¼Šï¼Šrob[i]);
            adj[v].emplace_back(u, suï¼Šï¼Šï¼Šrob[i]);
        }

        vector<double> probs(n, 0.0);
        probs[start_node] = 1.0;
        vector<bool> settled(n, false);

        while (true) {
            // å¯»æ‰¾å¤–å›´æ¦‚ç‡æœ€å¤§çš„ç‚¹
            int biggestV = -1;
            for (int v = 0; v < n; ++v) {
                if (settled[v] || probs[v] == 0.0) continue;
                if (biggestV == -1 || probs[biggestV] < probs[v])
                    biggestV = v;
            }
            if (biggestV == -1) return 0.0;
            if (biggestV == end_node) return probs[biggestV];

            settled[biggestV] = true;
            // æ¾å¼›
            for (const auto& edge : adj[biggestV]) {
                probs[edge.v] = max(probs[edge.v], probs[biggestV] * edge.prob);
            }
        }
    }
};
```

* []

```Python
# Python ä¼šè¶…æ—¶, ä¸‹ä¸€å°èŠ‚æœ‰å †ä¼˜åŒ–
class Solution:
    class Edge:
        def __init__(self, v: int, prob: float):
            self.v = v
            self.prob = prob

    def maxProbability(self, n: int, edges: List[List[int]], suï¼Šï¼Šï¼Šrob: List[float], start_node: int, end_node: int) -> float:
        # æ„å»ºé‚»æ¥è¡¨
        adj = defaultdict(list)
        for i in range(len(edges)):
            u, v = edges[i]
            adj[u].append(self.Edge(v, suï¼Šï¼Šï¼Šrob[i]))
            adj[v].append(self.Edge(u, suï¼Šï¼Šï¼Šrob[i]))

        probs = [0.0] * n
        probs[start_node] = 1.0
        settled = [False] * n

        while True:
            # å¯»æ‰¾å¤–å›´æ¦‚ç‡æœ€å¤§çš„ç‚¹
            biggestV = -1
            for v in range(n):
                if settled[v] or probs[v] == 0.0:
                    continue
                if biggestV == -1 or probs[biggestV] < probs[v]:
                    biggestV = v
            if biggestV == -1:
                return 0.0
            if biggestV == end_node:
                return probs[biggestV]

            settled[biggestV] = True
            # æ¾å¼›
            for edge in adj[biggestV]:
                probs[edge.v] = max(probs[edge.v], probs[biggestV] * edge.prob)
```

* []

```Java
class Solution {
    class Edge {
        int v;
        double prob;
        Edge(int v, double prob) {
            this.v = v;
            this.prob = prob;
        }
    }

    public double maxProbability(int n, int[][] edges, double[] suï¼Šï¼Šï¼Šrob, int start_node, int end_node) {
        // æ„å»ºé‚»æ¥è¡¨
        List<List<Edge>> adj = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            adj.add(new ArrayList<>());
        }
        for (int i = 0; i < edges.length; ++i) {
            int u = edges[i][0], v = edges[i][1];
            adj.get(u).add(new Edge(v, suï¼Šï¼Šï¼Šrob[i]));
            adj.get(v).add(new Edge(u, suï¼Šï¼Šï¼Šrob[i]));
        }

        double[] probs = new double[n];
        probs[start_node] = 1.0;
        boolean[] settled = new boolean[n];

        while (true) {
            // å¯»æ‰¾å¤–å›´æ¦‚ç‡æœ€å¤§çš„ç‚¹
            int biggestV = -1;
            for (int v = 0; v < n; ++v) {
                if (settled[v] || probs[v] == 0.0) continue;
                if (biggestV == -1 || probs[biggestV] < probs[v])
                    biggestV = v;
            }
            if (biggestV == -1) return 0.0;
            if (biggestV == end_node) return probs[biggestV];

            settled[biggestV] = true;
            // æ¾å¼›
            for (Edge edge : adj.get(biggestV)) {
                probs[edge.v] = Math.max(probs[edge.v], probs[biggestV] * edge.prob);
            }
        }
    }
}
```

* []

```Kotlin
class Solution {
    data class Edge(val v: Int, val prob: Double)

    fun maxProbability(n: Int, edges: Array<IntArray>, suï¼Šï¼Šï¼Šrob: DoubleArray, start_node: Int, end_node: Int): Double {
        // æ„å»ºé‚»æ¥è¡¨
        val adj = List(n){ mutableListOf<Edge>() }
        for(i in edges.indices){
            val (u, v) = edges[i]
            adj[u] += Edge(v, suï¼Šï¼Šï¼Šrob[i])
            adj[v] += Edge(u, suï¼Šï¼Šï¼Šrob[i])
        }

        val probs = DoubleArray(n)
        probs[start_node] = 1.0
        val settled = BooleanArray(n)

        while(true){
            // å¯»æ‰¾å¤–å›´æ¦‚ç‡æœ€å¤§çš„ç‚¹
            var biggestV = -1
            for(v in 0..<n){
                if(settled[v] || probs[v] == 0.0) continue
                if(biggestV == -1 || probs[biggestV] < probs[v]) 
                    biggestV = v
            }
            if(biggestV == -1) return 0.0
            if(biggestV == end_node) return probs[biggestV]

            settled[biggestV] = true
            // æ¾å¼›
            for((v, prob) in adj[biggestV]){
                probs[v] = max(probs[v], probs[biggestV] * prob)
            }
        }
    }
}
```

# å †ä¼˜åŒ–

æˆ‘ä»¬å¯ä»¥å°†æœ‰æ•ˆæ¾å¼›åçš„å¤–å›´ç‚¹åŠä¿¡æ¯å­˜å‚¨åœ¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ä¸­ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦èƒ½è¾¾åˆ° $O(V + E\cdot log\ E)$ï¼Œé€‚ç”¨äºç¨€ç–å›¾ã€‚

æ ¹æ®é¢˜ä¸­çš„æç¤ºéƒ¨åˆ†ï¼Œå¯çŸ¥è¯¥å›¾æ˜¯ç¨€ç–å›¾ï¼Œæ‰€ä»¥ä¸»æµè§£æ³•æ˜¯äºŒå‰å †æŸ¥æ‰¾ä¼˜åŒ–çš„ç‰ˆæœ¬ã€‚ä½†è¿™ä¸å±äºå†…åœ°æœ¬ç§‘çš„æ•™å­¦èŒƒå›´ï¼Œåœ¨é¢è¯•ä¸­ä¹Ÿç»å¸¸ä¸å¤ªè‹›åˆ»ã€‚

äºŒå‰å †æŸ¥æ‰¾ä¼˜åŒ–æ­£å¥½å±äº[ã€Šå›¾è®ºè¿›é˜¶ã€‹](https://leetcode.cn/leetbook/detail/advanced-graph-theory/) ä¸­å…è´¹çš„è¯•è¯»éƒ¨åˆ†ï¼Œè¯»è€…æœ‰å…´è¶£å¯ä»¥ç»“åˆ[ã€Šå›¾è®ºå…¥é—¨ã€‹](https://leetcode.cn/leetbook/detail/introduction-to-graph/)ä¸­ Prim ç®—æ³•çš„ä¸¤ç§å †æŸ¥æ‰¾ä¼˜åŒ–çœ‹ä¸€ä¸‹ï¼Œå‡æœ‰ PPT åŠ¨ç”»ã€‚

æ­¤å¤„ä»…ç»™å‡ºä»£ç ã€‚

* []

```C++
class Solution {
public:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& suï¼Šï¼Šï¼Šrob, int start_node, int end_node) {
        // æ„å»ºé‚»æ¥è¡¨
        vector<vector<pair<int, double>>> adj(n);
        for (int i = 0; i < edges.size(); ++i) {
            int u = edges[i][0], v = edges[i][1];
            adj[u].emplace_back(v, suï¼Šï¼Šï¼Šrob[i]);
            adj[v].emplace_back(u, suï¼Šï¼Šï¼Šrob[i]);
        }

        vector<double> probs(n, 0.0);
        probs[start_node] = 1.0;
        vector<bool> settled(n, false);
        // æŒ‰æƒé‡é™åºæ’åˆ—
        priority_queue<pair<double, int>> pq;
        pq.emplace(1.0, start_node);

        while (!pq.empty()) {
            // ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å¯»æ‰¾å¤–å›´æ¦‚ç‡æœ€å¤§çš„ç‚¹, suProb è¡¨ç¤ºä»æºç‚¹ s åˆ° u çš„ prob
            auto [suProb, u] = pq.top(); pq.pop();
            if (settled[u]) continue;
            settled[u] = true;
            if (u == end_node) return suProb;
            // æ¾å¼›
            for (const auto& [v, prob] : adj[u]) {
                double newProb = suProb * prob;
                if (probs[v] < newProb) {
                    probs[v] = newProb;
                    pq.emplace(newProb, v);
                }
            }
        }

        return 0.0;
    }
};
```

* []

```Python
class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], suï¼Šï¼Šï¼Šrob: List[float], start_node: int, end_node: int) -> float:
        # æ„å»ºé‚»æ¥è¡¨
        adj = defaultdict(list)
        for i in range(len(edges)):
            u, v = edges[i]
            adj[u].append((v, suï¼Šï¼Šï¼Šrob[i]))
            adj[v].append((u, suï¼Šï¼Šï¼Šrob[i]))

        probs = [0.0] * n
        probs[start_node] = 1.0
        settled = [False] * n
        # æŒ‰æƒé‡é™åºæ’åˆ—
        pq = [(-1.0, start_node)]
        heapq.heapify(pq)

        while pq:
            # ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å¯»æ‰¾å¤–å›´æ¦‚ç‡æœ€å¤§çš„ç‚¹, suProb è¡¨ç¤ºä»æºç‚¹ s åˆ° u çš„ prob
            suProb, u = heapq.heappop(pq)
            suProb = -suProb
            if settled[u]: continue
            settled[u] = True
            if u == end_node: return suProb
            # æ¾å¼›
            for v, prob in adj[u]:
                newProb = suProb * prob
                if probs[v] < newProb:
                    probs[v] = newProb
                    heapq.heappush(pq, (-newProb, v))

        return 0.0
```

* []

```Java
class Solution {
    public double maxProbability(int n, int[][] edges, double[] suï¼Šï¼Šï¼Šrob, int start_node, int end_node) {
        // æ„å»ºé‚»æ¥è¡¨
        List<List<Pair<Integer, Double>>> adj = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            adj.add(new ArrayList<>());
        }
        for (int i = 0; i < edges.length; ++i) {
            int u = edges[i][0], v = edges[i][1];
            adj.get(u).add(new Pair<>(v, suï¼Šï¼Šï¼Šrob[i]));
            adj.get(v).add(new Pair<>(u, suï¼Šï¼Šï¼Šrob[i]));
        }

        double[] probs = new double[n];
        probs[start_node] = 1.0;
        boolean[] settled = new boolean[n];
        // æŒ‰æƒé‡é™åºæ’åˆ—
        PriorityQueue<Pair<Double, Integer>> pq = new PriorityQueue<>((a, b) -> Double.compare(b.getKey(), a.getKey()));
        pq.add(new Pair<>(1.0, start_node));

        while (!pq.isEmpty()) {
            // ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å¯»æ‰¾å¤–å›´æ¦‚ç‡æœ€å¤§çš„ç‚¹, suProb è¡¨ç¤ºä»æºç‚¹ s åˆ° u çš„ prob
            Pair<Double, Integer> pair = pq.poll();
            double suProb = pair.getKey();
            int u = pair.getValue();
            if (settled[u]) continue;
            settled[u] = true;
            if (u == end_node) return suProb;
            // æ¾å¼›
            for (Pair<Integer, Double> next : adj.get(u)) {
                int v = next.getKey();
                double prob = next.getValue();
                double newProb = suProb * prob;
                if (probs[v] < newProb) {
                    probs[v] = newProb;
                    pq.add(new Pair<>(newProb, v));
                }
            }
        }

        return 0.0;
    }
}
```

* []

```Kotlin
class Solution {
    fun maxProbability(n: Int, edges: Array<IntArray>, suï¼Šï¼Šï¼Šrob: DoubleArray, start_node: Int, end_node: Int): Double {
        // æ„å»ºé‚»æ¥è¡¨
        val adj = List(n){ mutableListOf<Pair<Int, Double>>() }
        for(i in edges.indices){
            val (u, v) = edges[i]
            adj[u] += v to suï¼Šï¼Šï¼Šrob[i]
            adj[v] += u to suï¼Šï¼Šï¼Šrob[i]
        }

        val probs = DoubleArray(n)
        probs[start_node] = 1.0
        val settled = BooleanArray(n)
        // æŒ‰æƒé‡é™åºæ’åˆ—
        val pq = PriorityQueue<Pair<Int, Double>>(compareByDescending{ it.second })
        pq += start_node to 1.0

        while(pq.any()){
            // ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å¯»æ‰¾å¤–å›´æ¦‚ç‡æœ€å¤§çš„ç‚¹, suProb è¡¨ç¤ºä»æºç‚¹ s åˆ° u çš„ prob
            val (u, suProb) = pq.remove()
            if(settled[u]) continue
            settled[u] = true
            if(u == end_node) return suProb
            // æ¾å¼›
            for((v, prob) in adj[u]){
                val newProb = suProb * prob
                if(probs[v] < newProb){
                    probs[v] = newProb
                    pq += v to newProb
                }
            }
        }

        return 0.0
    }
}
```

# é¢˜å¤–

1. åœ¨å¾ªç¯ä¸­ä¸åˆ¤æ–­æ˜¯å¦æå‰é‡åˆ° `end_node` ä¹Ÿèƒ½é€šè¿‡ï¼Œæœ€åè¿”å› `probs[end_node]` å³å¯ã€‚
2. åœ¨å †æŸ¥æ‰¾ä¼˜åŒ–ä¸­é’ˆå¯¹æœ¬é¢˜ç§»é™¤æ•°ç»„ `probs`ä¹Ÿèƒ½é€šè¿‡ã€‚

ä»¥ä¸Šå‡ä¸å½±å“æœ€åçš„æ—¶é—´å¤æ‚åº¦ã€‚ä½†æ˜¯æˆ‘ä»¬åº”è¯¥åˆ†æç®—æ³•çš„è¿è¡Œè¿‡ç¨‹ï¼Œé…Œæƒ…åœ¨å¢åŠ çš„ä»£ç é‡å’Œå®é™…èŠ‚çœçš„è€—æ—¶ä¹‹é—´æŠ‰æ‹©ã€‚
