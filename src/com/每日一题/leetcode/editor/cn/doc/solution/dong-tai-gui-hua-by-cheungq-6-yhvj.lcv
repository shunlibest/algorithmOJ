当我们分析的时候，假设当前在第i位置，如果想要能追加到前面的摆动序列的结尾，那么我们需要知道一个事情，之前的这摆动序列的结尾是升序还是降序的
这样的情况下，我们建立了2维dp数组
1. dp[i][0]表示，到当前位置，以降序结尾的摆动数组的最长子序列的长度
2. dp[i][1]表示，到当前位置，以升序结尾的摆动数组的最长子序列的长度
3. 所以如果当前是升序的话，则当前位置的升序结尾的最长子序列的长度可以由之前的降序最长子序列的长度加1，此时的降序继续继承前一个状态的长度。
4. 若当前是降序同理
5. 最终以为我们统计的实际是能追加的个数，需要在结果上再加1表示加上一开始初始的节点个数

![自定义 (5).png](https://pic.leetcode-cn.com/1633692974-LMTDNI-%E8%87%AA%E5%AE%9A%E4%B9%89%20(5).png)

# 代码

* 

```
class Solution {
    /**
     * 输入：nums = [1,17,5,10,13,15,10,5,16,8]
     *          1, 17,  5, 10, 13, 15, 10,  5, 16,  8
     *             升   降  升  升  升   降   降  升  降
     *  降序结尾 0  0   2   2   2   2   4    4   4   6
     *  升序结尾 0  1   1   3   3   3   3    5   5   5
     *  if 升 {
     *     dp[i][降] = dp[i-1][降]
     *     dp[i][升] = dp[i-1][降]+1
     *  }
     *  if 降{
     *      dp[i][降] = dp[i-1][升]+1
     *      dp[i][升] = dp[i-1][升]
     *  }
     *
     * @param nums
     * @return
     */
    public int wiggleMaxLength(int[] nums) {
        int[][] dp = new int[nums.length][2];
        int i = 1;
        for (; i < nums.length; i++) {
            //dp[i][0]降序结尾
            //dp[i][1]升序结尾
            if (nums[i] > nums[i-1]){
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][0]+1;
            }else if (nums[i] < nums[i-1]){
                dp[i][0] = dp[i-1][1]+1;
                dp[i][1] = dp[i-1][1];
            }else{
                //相等
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][1];
            }
        }
        return Math.max(dp[--i][0],dp[i][1])+1;
    }
}
```

至于更进一步的`dp[i]`数组转化为两个变量的写法就省略不写了，我们可以很明白的看到`dp[i]`的状态只依赖于`dp[i-1]`这样就可以直接用两个变量代替原来的`dp[i]`数组，这里写作数组的形式只是为了更加便于理解动态规划方法的实现原理
