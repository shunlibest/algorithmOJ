## 解法：DP

一次反转会让原来 `s1` 和 `s2` 不同的位变得相同，或者让原来相同的位变得不同。因此我们先计算另一个字符串 `s`，若 `s1[i] == s2[i]` 则 `s[i] = 0`，否则 `s[i] = 1`。我们的目标就是把字符串 `s` 变成全零字符串。

由于一系列反转操作任意改变顺序，操作的最终结果还是相同的，因此我们不妨从左到右考虑对每一位进行怎样的操作。

* 如果 `s[i] == 1`，我们有这些操作可用：
  * 让 `s[i]` 和 `s[i + 1]` 都反转，代价为 $1$。
  * 让 `s[i]` 和后面的某个 $1$ 反转，代价为 $x$。
  * “蹭”一下前面的位执行的第二种操作（也就是作为“后面的某个 $1$”），代价为 $0$。
* 如果 `s[i] == 0`，那么不需要执行任何操作。读者可能会有疑问：那会不会先让 `s[i]` 和 `s[i + 1]` 都反转，然后再让 `s[i]` 和后面的某个 $1$ 反转呢？这样做的效果，其实等价于直接让 `s[i + 1]` 和后面的某个 $1$ 反转，还节省了 $1$ 的代价。所以 `s[i] == 0` 不需要执行操作。

根据上面的分析，我们即可设计 DP 状态。维护 `f[i][j = 0/1][k = 0/1]` 表示已经对前 $i$ 位执行了操作，$j = 0/1$ 表示第 $i$ 位执行的是不是第一种操作（也就是说下一位要不要反转），$k = 0/1$ 表示有没有免费的第二种操作可以“蹭”。转移方程如下：

* c++

```c++
// 算出下一位是 0 还是 1
int nxt = s[i + 1] ^ j;

if (nxt) {
    // 下一位是 1，枚举三种操作

    // 操作一：让 s[i + 1] 和 s[i + 2] 都反转
    // 因为执行了操作一，所以第二维固定是 1，第三维不受操作一影响，不改变
    f[i + 1][1][k] = min(f[i + 1][1][k], f[i][j][k] + 1);

    // 操作二：让 s[i] 和后面的某个 1 反转
    if (k == 0) f[i + 1][0][1] = min(f[i + 1][0][1], f[i][j][k] + x);
    // 操作三：“蹭”前面的操作二
    else f[i + 1][0][0] = min(f[i + 1][0][0], f[i][j][k]);
} else {
    // 下一位是 0，不进行任何操作
    // 因为不进行任何操作，所以第二维是 0，第三维不变
    f[i + 1][0][k] = min(f[i + 1][0][k], f[i][j][k]);
}
```

第 $n$ 位不能执行操作一，也不能有未被蹭完的操作二，因此最终答案就是 `f[n][0][0]`。复杂度 $\mathcal{O}(n)$。

## 参考代码（c++）

* c++

```c++
class Solution {
public:
    int minOperations(string s1, string s2, int x) {
        int n = s1.size();
        // 算出我们要处理的字符串
        vector<int> vec;
        for (int i = 0; i < n; i++) vec.push_back(s1[i] == s2[i] ? 0 : 1);

        const int INF = 1e9;
        int f[n + 1][2][2];
        for (int i = 0; i <= n; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) f[i][j][k] = INF;
        // 初值
        f[0][0][0] = 0;

        // dp
        for (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) {
            int nxt = vec[i] ^ j;
            if (nxt) {
                f[i + 1][1][k] = min(f[i + 1][1][k], f[i][j][k] + 1);
                if (k == 0) f[i + 1][0][1] = min(f[i + 1][0][1], f[i][j][k] + x);
                else f[i + 1][0][0] = min(f[i + 1][0][0], f[i][j][k]);
            } else {
                f[i + 1][0][k] = min(f[i + 1][0][k], f[i][j][k]);
            }
        }

        return f[n][0][0] < INF ? f[n][0][0] : -1;
    }
};
```

