**提前说明**

为了便于表述，本题解中把第一种操作方法称为任意替换，第二种操作方法称为距离替换。

本题解中涉及到的各变量以及含义：
dp：动态规划记录，dp[i][j]表示在扫描字符串至j时，处于第i种状态的代价（推论中会说明含义）
dis：距离记录（推论中会说明其含义）

**推论**
- 我们在处理s1和s2字符串时不必考虑是否是1还是0，我们需要关注的信息是两者是否相等，所以我们可以将s1与s2异或得到一个新的字符串（列表），第i位为0时表示该位不需要反转，为1时表示该位需要反转，之后仅需要围绕该列表展开讨论与解答即可
- 可以通过多次的距离替换操作来进行两个远距离标记的反转，其代价为j-i，其中j和i为其下标
- 我们得到上述标记列表之后，我们可以发现，每一个标记要么通过任意替换来反转，要么通过距离替换来反转，且一定是两个标记成对反转。针对前i个字符串，如果前i个字符中有某个字符与第i+1或之后的字符共同反转，我们称这前i个字符串有未完成的反转操作。
- 针对前i个字符，有如下四种可能：1.没有未完成的反转操作 2.未完成任意替换操作 3.未完成距离替换操作 4.两种操作均未完成。四种可能情况即为dp中的状态
- 对于异或列表中顺序出现的a,b,c,d四个位置，若其均为距离替换，则最小为a、b进行替换，c、d进行替换，而不是a、c，b、d或者a、d，b、c替换
- 对于前i个字符未完成距离替换的情况，我们可以推得：其中未完成距离替换操作所对应的字符一定是前i个字符串中最后需要反转的字符，否则我们可以将其与前面已经完成操作的字符或者进行任意替换的字符进行“交换”，得到一个更小的代价的方法。
- 根据上面两条我们注意到，前i个字符中未完成距离替换的字符对应的操作代价我们可以提前计算出来，即为该字符与后续需要反转字符的距离，即为dis

**流程**

1. 取得两字符串的异或字符串（列表）
2. 将其中的列表进行距离计算，得出dis列表
3. 动态规划计算各个情况所需的操作（其中详细情况分类在代码中注释标出 ）
4. 扫描字符串完成时第一状态的值即为答案，即dp[0][len(s1)]

* 

```
class Solution(object):
    # 考虑dp情况不存在的取最小值函数
    def min(self,a,b):
        if a == -1:
            return b
        if b == -1:
            return a
        return a if a<b else b
        
    def minOperations(self, s1, s2, x):
        """
        :type s1: str
        :type s2: str
        :type x: int
        :rtype: int
        """
        # 得到需要反转的标记列表
        t = list(s1)
        for i in range(len(s1)):
            if s1[i] != s2[i]:
                t[i] = 1
            else:
                t[i] = 0
        dp = [[0  for _ in range(1+len(t))]for _ in range(4)]
        # 初始化边界条件，这里dp[1][0]表示扫描至第0个字符串时第二种状态的代价（由于开始时不可能有第二三四种状态，所以初始化为-1）
        dp[0][0] = 0
        dp[1][0] = -1
        dp[2][0] = -1
        dp[3][0] = -1
        # 计算距离列表
        dis = [-1 for _ in range(len(t))]
        before = -1
        for i in range(len(t)):
            if t[i] == 1:
                dis[i] = i - before
                before = i
        # 动态规划计算结果
        for i in range(len(t)):
            if t[i] == 0:
                # 如果该字符不需要反转，那么直接继承之前的状态
                dp[0][i+1] = dp[0][i]
                dp[1][i+1] = dp[1][i]
                dp[2][i+1] = dp[2][i]
                dp[3][i+1] = dp[3][i]
            else:
                # 如果该字符反转后，达到第一种状态，那么可能是第二种状态或者第三种状态转换过来的，取最小的代价作为目前结果
                a = (dp[1][i] + x) if dp[1][i] != -1 else -1
                b = (dp[2][i] + dis[i]) if dp[2][i]!=-1 else -1
                dp[0][i+1] = self.min(a,b)
                # 如果该字符反转后，达到第二种状态，那么可能是第一种状态或者第四种状态转换过来的，取最小的代价作为目前结果
                a = (dp[3][i] + dis[i]) if dp[3][i] != -1 else -1
                b = (dp[0][i]) if dp[0][i] != -1 else -1
                dp[1][i+1] = self.min(a,b)
                # 如果该字符反转后，达到第三种状态，那么可能是第一种状态或者第四种状态转换过来的，取最小的代价作为目前结果
                a = (dp[3][i] + x) if dp[3][i] != -1 else -1
                b = (dp[0][i]) if dp[0][i] != -1 else -1
                dp[2][i+1] = self.min(a,b)
                # 如果该字符反转后，达到第四种状态，那么可能是第二种状态或者第三种状态转换过来的，取最小的代价作为目前结果
                a = (dp[2][i] ) if dp[2][i] != -1 else -1
                b = (dp[1][i] ) if dp[1][i] != -1 else -1
                dp[3][i+1] = self.min(a,b)
        return dp[0][len(t)]
```

**优化**
注意到上述代码空间时间均为O(n)复杂度，而循环中dp实际上只用到了dp[x][i]和dp[x][i+1],其中x=0,1,2,3，可以将其优化成O(n)复杂度
