### æ–¹æ³•ä¸€ï¼šBFS

æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ $g$ï¼Œå…¶ä¸­ $g[i]$ è¡¨ç¤ºç‚¸å¼¹ $i$ çš„çˆ†ç‚¸èŒƒå›´å†…å¯ä»¥å¼•çˆ†çš„æ‰€æœ‰ç‚¸å¼¹çš„ä¸‹æ ‡ã€‚

ç„¶åï¼Œæˆ‘ä»¬éå†æ‰€æœ‰ç‚¸å¼¹ï¼Œå¯¹äºä¸¤ä¸ªç‚¸å¼¹ $(x_1, y_1, r_1)$ å’Œ $(x_2, y_2, r_2)$ï¼Œæˆ‘ä»¬è®¡ç®—å®ƒä»¬ä¹‹é—´çš„è·ç¦» $\text{dist} = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$ã€‚å¦‚æœ $\text{dist} \leq r_1$ï¼Œé‚£ä¹ˆç‚¸å¼¹ $i$ çš„çˆ†ç‚¸èŒƒå›´å†…å¯ä»¥å¼•çˆ†ç‚¸å¼¹ $j$ï¼Œæˆ‘ä»¬å°±å°† $j$ æ·»åŠ åˆ° $g[i]$ ä¸­ã€‚å¦‚æœ $\text{dist} \leq r_2$ï¼Œé‚£ä¹ˆç‚¸å¼¹ $j$ çš„çˆ†ç‚¸èŒƒå›´å†…å¯ä»¥å¼•çˆ†ç‚¸å¼¹ $i$ï¼Œæˆ‘ä»¬å°±å°† $i$ æ·»åŠ åˆ° $g[j]$ ä¸­ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éå†æ‰€æœ‰ç‚¸å¼¹ï¼Œå¯¹äºæ¯ä¸ªç‚¸å¼¹ $k$ï¼Œæˆ‘ä»¬ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢è®¡ç®—ç‚¸å¼¹ $k$ çš„çˆ†ç‚¸èŒƒå›´å†…å¯ä»¥å¼•çˆ†çš„æ‰€æœ‰ç‚¸å¼¹çš„ä¸‹æ ‡ï¼Œå¹¶è®°å½•ä¸‹æ¥ã€‚å¦‚æœè¿™äº›ç‚¸å¼¹çš„æ•°é‡ç­‰äº $n$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å¼•çˆ†æ‰€æœ‰ç‚¸å¼¹ï¼Œç›´æ¥è¿”å› $n$ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬è®°å½•ä¸‹æ¥è¿™äº›ç‚¸å¼¹çš„æ•°é‡ï¼Œå¹¶è¿”å›æœ€å¤§å€¼ã€‚

* [sol1-Python3]

```python
class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        n = len(bombs)
        g = [[] for _ in range(n)]
        for i in range(n - 1):
            x1, y1, r1 = bombs[i]
            for j in range(i + 1, n):
                x2, y2, r2 = bombs[j]
                dist = hypot(x1 - x2, y1 - y2)
                if dist <= r1:
                    g[i].append(j)
                if dist <= r2:
                    g[j].append(i)
        ans = 0
        for k in range(n):
            vis = {k}
            q = [k]
            for i in q:
                for j in g[i]:
                    if j not in vis:
                        vis.add(j)
                        q.append(j)
            if len(vis) == n:
                return n
            ans = max(ans, len(vis))
        return ans
```

* [sol1-Java]

```java
class Solution {
    public int maximumDetonation(int[][] bombs) {
        int n = bombs.length;
        List<Integer>[] g = new List[n];
        Arrays.setAll(g, k -> new ArrayList<>());
        for (int i = 0; i < n - 1; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int[] p1 = bombs[i], p2 = bombs[j];
                double dist = Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
                if (dist <= p1[2]) {
                    g[i].add(j);
                }
                if (dist <= p2[2]) {
                    g[j].add(i);
                }
            }
        }
        int ans = 0;
        boolean[] vis = new boolean[n];
        for (int k = 0; k < n; ++k) {
            Arrays.fill(vis, false);
            vis[k] = true;
            int cnt = 0;
            Deque<Integer> q = new ArrayDeque<>();
            q.offer(k);
            while (!q.isEmpty()) {
                int i = q.poll();
                ++cnt;
                for (int j : g[i]) {
                    if (!vis[j]) {
                        vis[j] = true;
                        q.offer(j);
                    }
                }
            }
            if (cnt == n) {
                return n;
            }
            ans = Math.max(ans, cnt);
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int maximumDetonation(vector<vector<int>>& bombs) {
        int n = bombs.size();
        vector<int> g[n];
        for (int i = 0; i < n - 1; ++i) {
            for (int j = i + 1; j < n; ++j) {
                auto& p1 = bombs[i];
                auto& p2 = bombs[j];
                auto dist = hypot(p1[0] - p2[0], p1[1] - p2[1]);
                if (dist <= p1[2]) {
                    g[i].push_back(j);
                }
                if (dist <= p2[2]) {
                    g[j].push_back(i);
                }
            }
        }
        int ans = 0;
        bool vis[n];
        for (int k = 0; k < n; ++k) {
            memset(vis, false, sizeof(vis));
            queue<int> q;
            q.push(k);
            vis[k] = true;
            int cnt = 0;
            while (!q.empty()) {
                int i = q.front();
                q.pop();
                ++cnt;
                for (int j : g[i]) {
                    if (!vis[j]) {
                        vis[j] = true;
                        q.push(j);
                    }
                }
            }
            if (cnt == n) {
                return n;
            }
            ans = max(ans, cnt);
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func maximumDetonation(bombs [][]int) (ans int) {
	n := len(bombs)
	g := make([][]int, n)
	for i, p1 := range bombs[:n-1] {
		for j := i + 1; j < n; j++ {
			p2 := bombs[j]
			dist := math.Hypot(float64(p1[0]-p2[0]), float64(p1[1]-p2[1]))
			if dist <= float64(p1[2]) {
				g[i] = append(g[i], j)
			}
			if dist <= float64(p2[2]) {
				g[j] = append(g[j], i)
			}
		}
	}
	for k := 0; k < n; k++ {
		q := []int{k}
		vis := make([]bool, n)
		vis[k] = true
		cnt := 0
		for len(q) > 0 {
			i := q[0]
			q = q[1:]
			cnt++
			for _, j := range g[i] {
				if !vis[j] {
					vis[j] = true
					q = append(q, j)
				}
			}
		}
		if cnt == n {
			return n
		}
		ans = max(ans, cnt)
	}
	return
}
```

* [sol1-TypeScript]

```ts
function maximumDetonation(bombs: number[][]): number {
    const n = bombs.length;
    const g: number[][] = Array.from({ length: n }, () => []);
    for (let i = 0; i < n - 1; ++i) {
        const [x1, y1, r1] = bombs[i];
        for (let j = i + 1; j < n; ++j) {
            const [x2, y2, r2] = bombs[j];
            const d = Math.hypot(x1 - x2, y1 - y2);
            if (d <= r1) {
                g[i].push(j);
            }
            if (d <= r2) {
                g[j].push(i);
            }
        }
    }
    let ans = 0;
    for (let k = 0; k < n; ++k) {
        const vis: Set<number> = new Set([k]);
        const q: number[] = [k];
        for (const i of q) {
            for (const j of g[i]) {
                if (!vis.has(j)) {
                    vis.add(j);
                    q.push(j);
                }
            }
        }
        if (vis.size === n) {
            return n;
        }
        ans = Math.max(ans, vis.size);
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(n^2)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n^2)$ã€‚å…¶ä¸­ $n$ ä¸ºç‚¸å¼¹çš„æ•°é‡ã€‚

----

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~

