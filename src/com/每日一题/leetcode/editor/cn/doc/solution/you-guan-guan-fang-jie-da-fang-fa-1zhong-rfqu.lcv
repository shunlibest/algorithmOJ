这里首先复述下官解方法1的做法。用dp[i]来表示枚举到第i个题目时，可以获得的最大分数。
* 如果不选第i个题，有dp[i]=dp[i−1]
* 如果选第i个题，需要遍历j$\in$[0, i-1]，找到满足j + brainpower[j] < i的值最大的dp[j]，从其转移而来，有dp[i] = dp[j] + points[i]

最终dp[i]的结果则为dp[i] = max(dp[i - 1], dp[j] + points[i])，代码实现如下：

* 

```
class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions)
        dp = [0] * n
        dp[0] = questions[0][0]
        for i in range(1, n):
            not_select = dp[i - 1]  # 不解决
            select = questions[i][0]  # 解决
            plus = 0  # 如果从上一个已解决的题转化而来，可获得的额外分数
            for j in range(0, i):
                if j + questions[j][1] < i:
                    plus = max(plus, dp[j])
            dp[i] = max(not_select, select + plus)
        return dp[n - 1]
```

而以上解法是错误的(并非溢出问题)，只能通过一半的用例，一个较短的错误用例如下：

* 

```
[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1],[85,1],[84,2],[27,2],[47,5],[48,4],[3,2],[44,3],[60,5],[19,2],[9,4],[29,5],[15,3],[1,3],[60,2],[63,3],[79,3],[19,1],[7,1],[35,1],[55,4],[1,4],[41,1],[58,5]]
```

预计输出为：

* 

```
781
```

实际输出为：

* 

```
805
```

可以发现实际输出更大了，也就是多贪心了状态。那么问题出在哪呢？

这里举一个更简单的例子：

* 

```
[[100,5],[1,1],[1,2],[1,1]]
```

预计输出应为100，也就是只选第0个问题回答，而以上代码的输出为101。将此时的代码的dp数组输出，有：

* 

```
[100, 100, 100, 101]
```

其计算逻辑为：

* 

```
dp[0] = points[0] = 100
dp[1] = dp[0] = 100
dp[2] = dp[1] = 100
dp[3] = dp[1] + points[3] = 101 (因为dp[1]的brainpower[i]为1，与答第2题冲突，但与答第3题不冲突)
```

可以发现，问题出在dp[1]上。因为dp[1]是由dp[0]转移而来，**隐式的选择了dp[0]**，因此其实际的"脑力恢复期"为`max(0 + brainpower[0], 1 + brainbrainpower[1]) = 5`，而非`1 + brainbrainpower[1] = 2`。也就是说，判断dp[j]是否能由dp[i]转化而来，不能只依靠：

* 

```
if j + questions[j][1] < i:
    plus = max(plus, dp[j])
```

因为当遍历到第j个元素时，某个**小于j的已选元素k**的"脑力恢复期"可能**仍未结束**，因此不能只考虑选择j所造成的"脑力恢复期"。
