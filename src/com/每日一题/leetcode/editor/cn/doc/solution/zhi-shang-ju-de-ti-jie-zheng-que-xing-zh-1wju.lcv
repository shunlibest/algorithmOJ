首先要注意到1 <= n <= 5这个数据量，划重点，后面会用到。

为了解释方便，我们称子集大小的一半为“标准”。

首先讨论行子集只有1行时，此情况很简单，因为“标准”为0，所以必须有一行所有元素均为0，否则我们必须考虑选择更多的行来增大“标准”。

当子集行数为2时，“标准”为1，所以要找到两行按列相加后所有元素都小于等于1的行，也就是说必须有两行进行“&”运算后结果为0。如果找不出这样的两行，我们依然要考虑增加行数来增大“标准”。

当子集行数为3时，其“标准”依然为1，但却要多出一行，完全不用考虑。不仅行数为3时，所有行数为奇数时都会出现此情况，所以我们只需要考虑行数为偶数的子集。

当子集行数为4时，其“标准”为2，要注意到我们之所以会考虑到将子集取四行，是因为当子集行数为2时，无法找出两行进行“&”运算后结果为0的行，也就是说，将任意两行按列相加，都至少会出现一个2，那么子集行数为4时，能找出多少个2？根据组合数的知识，在4行中选2行有6种选法，所以至少会出现6个2，但是1 <= n <= 5，所以必然会有一列之和大于2，所以当子集行数为2时不行，那么子集行数为4时依然不行。不仅子集行数为4不行，接下来所有更大的偶数都不行,证明方法同理。

所以可以得到结论，如果子集取1行2行都不行，那么就不存在满足条件的取法，所以我们只需要考虑是否有一行元素全部为0，或者可以找出两行进行“&”运算后结果为0。

代码如下：

* 

```
class Solution {
public:
    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {
        vector<int> a[1<<5];
        vector<int> ans;
        int m=grid.size();
        int n=grid[0].size();
        for(int i=0;i<m;i++){
            int s=0;
            for(auto c:grid[i])
                s=(s<<1)+c;
            if(s==0){
                ans.push_back(i);
                return ans;
            }
            a[s].push_back(i);
        }
        for(int i=0;i<(1<<n);i++){
            if(a[i].size()==0) 
                continue;
            for(int j=i+1;j<(1<<n);j++){
                if(a[j].size()==0) 
                    continue;
                if((i&j)==0){
                    ans.push_back(a[i][0]);
                    ans.push_back(a[j][0]);
                    sort(ans.begin(),ans.end());
                    return ans;
                }
            }
        }
        return ans;
    }
};
```

